//! This module implements a new version of the runtime parser that
//! uses the LR statemachine generated by rustlr.  It will (for now), live
//! side along with the original parser implemented as [crate::RuntimeParser].
//! Since Version 0.2.3, this module can now generate a basic lexical 
//! scanner based on [crate::RawToken] and [crate::StrTokenizer].
//!
//! This module implements the parsing routines that uses the state machine
//! generated by rustlr.  **The main structure here is [BaseParser]**.
//! All parsing functions are organized around the [BaseParser::parse_core]
//! function, which implements the basic LR parsing algorithm.  This function
//! expects dynamic [Tokenizer] and [ErrReportMaker] trait-objects. 
//! This module provides generic
//! parsing and parser-training routines that use stdio for interface, but
//! the [ErrReportMaker] trait allows custom user interfaces to be build separately.

#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_assignments)]
#![allow(unused_doc_comments)]
#![allow(unused_imports)]
use std::fmt::Display;
use std::default::Default;
use std::collections::{HashMap,HashSet,BTreeSet};
use std::io::{self,Read,Write,BufReader,BufRead};
use std::rc::Rc;
use std::cell::{RefCell,Ref,RefMut};
use std::hash::{Hash,Hasher};
use std::any::Any;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;
use std::mem;
//use crate::{Stateaction,Statemachine,TerminalToken,Tokenizer};
use crate::{Stateaction,iserror,TerminalToken,Tokenizer};
use crate::{LBox,LRc,LC};
use crate::Stateaction::*;
use crate::{lbup,lbdown,lbget};
use crate::{StandardReporter,StackedItem};
#[cfg(feature = "generator")]
use crate::{Statemachine};

//extern crate termion;
//use termion::{color,style};


/// this structure is only exported because it is required by the generated parsers.
/// There is no reason to use it in other programs.  Replaces [crate::RProduction] for new parsers since version 0.2.0
#[derive(Clone)]
pub struct BaseProduction<'t,AT:Default,ET:Default,TT:Tokenizer<'t,AT>>  
{
  pub lhs: &'static str, // left-hand side nonterminal of rule
  pub Ruleaction : fn(&mut BaseParser<'t,AT,ET,TT>) -> AT, //parser as arg
}
impl<'t,AT:Default,ET:Default,TT:Tokenizer<'t,AT>> BaseProduction<'t,AT,ET,TT>
{
  pub fn new_skeleton(lh:&'static str) -> BaseProduction<'t,AT,ET,TT>
  {
     BaseProduction {
       lhs : lh,
       Ruleaction : |p|{ <AT>::default() },
     }
  }
}//impl BaseProduction

/* imported from runtime_parser module
/// These structures are what's on the parse stack.
pub struct StackedItem<AT:Default>   // replaces Stackelement
{
   si : usize, // state index
   pub value : AT, // semantic value (don't clone grammar symbols)
   pub line: usize,  // line and column
   pub column: usize, 
}
impl<AT:Default> StackedItem<AT>
{
  pub fn new(si:usize,value:AT,line:usize,column:usize) -> StackedItem<AT>
  { StackedItem{si,value,line,column} }
  /// converts the information in a stacked item to an [LBox] enclosing
  /// the abstract syntax value along with starting line and column numbers
  pub fn lbox(self) -> LBox<AT>  // no longer used
  {  LBox::new(self.value,self.line,self.column) }
}
*/

/// This is the structure created by the generated parser.  The generated parser
/// program will contain a make_parser function that returns this structure.
/// Most of the pub items are, however, only exported to support the operation
/// of the parser, and should not be accessed directly.  Only the functions
/// [BaseParser::parse], [BaseParser::report], [BaseParser::abort]
/// and [BaseParser::error_occurred] should be called directly 
/// from user programs.  Only the field [BaseParser::exstate] should be accessed
/// by user programs.
pub struct BaseParser<'ilt,AT:Default,ET:Default,TT:Tokenizer<'ilt,AT>>  
{
  /// this is the "external state" structure, with type ET defined by the grammar.
  /// The semantic actions associated with each grammar rule, which are written
  /// in the grammar, have ref mut access to the BaseParser structure, which
  /// allows them to read and change the external state object.  This gives
  /// the parsers greater flexibility and capability, including the ability to
  /// parse some non-context free languages.  See 
  /// [this sample grammar](<https://cs.hofstra.edu/~cscccl/rustlr_project/ncf.grammar>).
  /// The exstate is initialized to ET::default().
  pub exstate : ET,  // external state structure, usage optional
  /// External state that can be shared
  pub shared_state : Rc<RefCell<ET>>,
  /// used only by generated parser: do not reference
  pub RSM : Vec<HashMap<&'static str,Stateaction>>,  // runtime state machine
  // do not reference
  //pub Expected : Vec<Vec<&'static str>>,
  /// do not reference
  pub Rules : Vec<BaseProduction<'ilt,AT,ET,TT>>, //rules with just lhs and delegate function
  ////// this value should be set through abort or report
  stopparsing : bool,
  /// do not reference  
  pub stack :  Vec<StackedItem<AT>>, // parse stack
//  pub recover : HashSet<&'static str>, // for error recovery
  pub resynch : HashSet<&'static str>,
  pub Errsym : &'static str,
  err_occurred : bool,
  /// axiom: linenum and column represents the starting position of the
  /// topmost StackedItem.
  pub linenum : usize,
  pub column : usize,
  pub position : usize, // absolute byte position of input
  pub prev_position : usize,
  pub src_id : usize,
  report_line : usize,
  /// Hashset containing all grammar symbols (terminal and non-terminal). This is used for error reporting and training.
  pub Symset : HashSet<&'static str>,
  pub tokenizer:&'ilt mut TT,
  popped : Vec<(usize,usize)>,
  gindex : RefCell<u32>,  // global index for uid
  err_report : Option<String>, // optional err report with logging reporter
}//struct BaseParser

// 't is input lifetime
impl<'t,AT:Default,ET:Default,TT:Tokenizer<'t,AT>> BaseParser<'t,AT,ET,TT>
{
    /// this is only called by the make_parser function in the machine-generated
    /// parser program.  *Do not call this function in other places* as it
    /// only generates a skeleton.
    pub fn new(rlen:usize, slen:usize, tk:&'t mut TT) -> Self
    {  // given number of rules and number states
       let mut p = BaseParser {
         RSM : Vec::with_capacity(slen),
         //Expected : Vec::with_capacity(slen),
         Rules : Vec::with_capacity(rlen),
         stopparsing : false,
         exstate : ET::default(),
         shared_state: Rc::new(RefCell::new(ET::default())),
         stack : Vec::with_capacity(1024),
         Errsym : "",
         err_occurred : false,
         linenum : 0,
         column : 0,
         position : 0,
         prev_position: 0,
         src_id : 0,
         report_line : 0,
         resynch : HashSet::new(),
         Symset : HashSet::with_capacity(64),
         tokenizer:tk,
         popped: Vec::with_capacity(8),
         gindex: RefCell::new(0),
         err_report : None,
       };
       for _ in 0..slen {
         p.RSM.push(HashMap::with_capacity(16));
         //p.Expected.push(Vec::new());
       }
       return p;
    }//new

    /// returns the current line number
    pub fn current_line(&self)->usize {self.linenum}
    /// returns the current column number
    pub fn current_column(&self)->usize {self.column}
    /// returns the current absolute byte position according to tokenizer
    pub fn current_position(&self)->usize {self.position}
    /// returns the previous position (before shift) according to tokenizer
    pub fn previous_position(&self)->usize {self.prev_position}

    /// this function can be called from within the semantic actions attached
    /// to grammar production rules that are executed for each
    /// "reduce" action of the parser.
    pub fn abort(&mut self, msg:&str)
    {
       self.err_report.as_mut().map_or_else(
         ||eprintln!("\n!!!Parsing Aborted: {}",msg),
         |x|x.push_str(&format!("\n!!!Parsing Aborted: {}\n",msg)));

       self.err_occurred = true;
       self.stopparsing=true;
    }


    /// this function can be called from within the "semantic" actions attached
    /// to production rules to terminate parsing.
    pub fn stop(&mut self) {
      self.stopparsing = true;
    }

    /// may be called from grammar semantic actions to report error.
    /// this report function will print to stdout.
    pub fn report(&mut self, errmsg:&str)  {self.report_error(errmsg,false)}
    /// same as [BaseParser::report] but with option to display line/column
    pub fn report_error(&mut self, errmsg:&str, showlc: bool)  
    {  
       //eprint!("{}",color::Fg(color::Yellow));
       if (self.report_line != self.linenum || self.linenum==0)  {
         if showlc {
           self.err_report.as_mut().map_or_else(
             ||eprintln!("ERROR on line {}, column {}: {}",self.linenum,self.column,errmsg),
             |x|x.push_str(&format!("ERROR on line {}, column {}: {}\n",self.linenum,self.column,errmsg)));
         }
         else {
           self.err_report.as_mut().map_or_else(
             ||eprintln!("PARSER ERROR: {}",errmsg),
             |x|x.push_str(&format!("PARSER ERROR: {}\n",errmsg)));
         }
         self.report_line = self.linenum;
       }
       else {
         if showlc {
           self.err_report.as_mut().map_or_else(
             ||eprint!(" ({},{}): {}",self.linenum,self.column,errmsg),
             |x|x.push_str(&format!(" ({},{}): {}",self.linenum,self.column,errmsg)));
         }
         else {
           self.err_report.as_mut().map_or_else(
             ||eprint!(" {}",errmsg),
             |x|{x.push(' '); x.push_str(errmsg)});
         }
       }
       //eprint!("{}",color::Fg(color::Reset));       
       self.err_occurred = true;
    }// report

    /// this function is only exported to support the generated code
    pub fn bad_pattern(&mut self,pattern:&str) -> AT
    {
       let msg = format!("pattern {} failed to bind to stacked values\n",pattern);
       self.report(&msg);
       //println!("FROM BAD PATTERN:");
       AT::default()
    }

    //called to simulate a shift
    fn errshift(&mut self, sym:&str) -> bool
    {
       let csi = self.stack[self.stack.len()-1].si; // current state
       let actionopt = self.RSM[csi].get(sym);
       if let Some(Shift(ni)) = actionopt {
         self.stack.push(StackedItem::new(*ni,AT::default(),self.linenum,self.column)); true
       }
       else {false}
    }

  // this is the LR parser shift action: push the next state, along with the
  // value of the current lookahead token onto the parse stack, returns the
  // next token
  fn shift(&mut self, nextstate:usize, lookahead:TerminalToken<'t,AT>) -> TerminalToken<'t, AT>
  {
     self.linenum = lookahead.line;  self.column=lookahead.column;
     self.prev_position = self.position;
     self.position = self.tokenizer.position();
     self.stack.push(StackedItem::new(nextstate,lookahead.value,lookahead.line,lookahead.column));
     self.tokenizer.next_tt()
  }

    /// this function is called from the generated semantic actions and should
    /// most definitely not be called from elsewhere as it would corrupt
    /// the base parser.
    pub fn popstack(&mut self) -> StackedItem<AT>
    {
       let item = self.stack.pop().expect("PARSER STATE MACHINE/STACK CORRUPTED");
       self.linenum = item.line; self.column=item.column;
       self.popped.push((item.line,item.column));
       item
    }//popstack

    pub fn popstack_as_lbox(&mut self) -> LBox<AT>
    {
       let item = self.stack.pop().expect("PARSER STATE MACHINE/STACK CORRUPTED");
       self.linenum = item.line; self.column=item.column;
       self.popped.push((item.line,item.column));
       let newuid = *self.gindex.borrow();
       *self.gindex.borrow_mut() += 1;           
       LBox::make(item.value,item.line,item.column,newuid)
    }//popstack_as_lbox

    fn reduce(&mut self, ri:&usize)
    {
       self.popped.clear();
       let rulei = &self.Rules[*ri];
       let ruleilhs = rulei.lhs; // &'static : Copy
       let val = (rulei.Ruleaction)(self); // should be self
       let newtop = self.stack[self.stack.len()-1].si; 
       let goton = self.RSM[newtop].get(ruleilhs).expect("PARSER STATEMACHINE CORRUPTED");
       if let Stateaction::Gotonext(nsi) = goton {
       self.stack.push(StackedItem::new(*nsi,val,self.linenum,self.column)); 
                //self.stack.push(Stackelement{si:*nsi,value:val});
       }// goto next state after reduce
              else {
                self.report("state transition table corrupted: no suitable action after reduce");
                self.stopparsing=true;
              }
    }//reduce

    /// can be called to determine if an error occurred during parsing.  The parser
    /// will not panic.
    pub fn error_occurred(&self) -> bool {self.err_occurred}

    // there may need to be other lb functions, perhaps from terminalToken
    // or stackedItem (at least for transfer)

    /// creates a [LBox] smart pointer that includes line/column information;
    /// should be called from the semantic actions of a grammar rule, e.g.
    ///```ignore
    ///   E --> E:a + E:b {PlusExpr(parser.lb(a),parser.lb(b))}
    ///```
    pub fn lb<T>(&self,e:T) -> LBox<T> {
      let newuid = *self.gindex.borrow();
      *self.gindex.borrow_mut() += 1;    
      LBox::make(e,self.linenum,self.column,newuid)
    }
    /// creates a `LBox<dyn Any>`, which allows attributes of different types to
    /// be associated with grammar symbols.  Use in conjuction with [LBox::downcast], [LBox::upcast] and the [lbdown], [lbup] macros.
    pub fn lba<T:'static>(&self,e:T) -> LBox<dyn Any> {
      let newuid = *self.gindex.borrow();
      *self.gindex.borrow_mut() += 1;        
      LBox::upcast(LBox::make(e,self.linenum,self.column,newuid))
    }
    /// similar to [BaseParser::lb], but creates a [LRc] instead of [LBox]
    pub fn lrc<T>(&self,e:T) -> LRc<T> { LRc::new(e,self.linenum,self.column /*,self.src_id*/) }
    /// similar to [BaseParser::lba] but creates a [LRc]
    pub fn lrca<T:'static>(&'t self,e:T) -> LRc<dyn Any> { LRc::upcast(LRc::new(e,self.linenum,self.column /*,self.src_id*/)) }

    /// creates LBox enclosing e using line/column information associated
    /// with right-hand side symbols, numbered left-to-right starting at 0
    pub fn lbx<T>(&self,i:usize,e:T) -> LBox<T>
    {
       let (mut ln,mut cl) = (self.linenum,self.column);
       if i<self.popped.len() {
         let index = self.popped.len() - 1 - i;
         let lc = self.popped[index];
         ln = lc.0; cl=lc.1;
       }
       let newuid = *self.gindex.borrow();
       *self.gindex.borrow_mut() += 1;
       LBox::make(e,ln,cl,newuid)
    }//lbx

    /// alias for [Self::lbx]
    pub fn lbox<T>(&self,i:usize,e:T) -> LBox<T> { self.lbx(i,e) }

    /// creates [LC] enclosing e using line/column information associated
    /// with right-hand side symbols, numbered left-to-right starting at 0
    pub fn lc<T>(&self,i:usize,e:T) -> LC<T>
    {
       let (mut ln,mut cl) = (self.linenum,self.column);
       if i<self.popped.len() {
         let index = self.popped.len() - 1 - i;
         let lc = self.popped[index];
         ln = lc.0; cl=lc.1;
       }
       let uid = *self.gindex.borrow();
       *self.gindex.borrow_mut() += 1;
       LC::make(e,ln,cl,uid)
    }//lbx

    /// Like lbx but creates an LRc
    pub fn lrcn<T>(&self,i:usize,e:T) -> LRc<T>
    {
       let (mut ln,mut cl) = (self.linenum,self.column);
       if i<self.popped.len() {
         let index = self.popped.len() - 1 - i;
         let lc = self.popped[index];
         ln = lc.0; cl=lc.1;
       }
       LRc::new(e,ln,cl)
    }//lbx
}// impl BaseParser


///////////////////////////////////////////////////////////////////////////
impl<'t,AT:Default,ET:Default,TT:Tokenizer<'t,AT>> BaseParser<'t,AT,ET,TT>
{
  /// Error recovery routine of rustlr, separate from error_reporter.
  /// This function will modify the parser and lookahead symbol and return
  /// either the next action the parser should take (if recovery succeeded)
  /// or None if recovery failed.
  pub fn error_recover(&mut self, lookahead:&mut TerminalToken<'t,AT>) -> Option<Stateaction>
  {
    let mut erraction = None;
    ///// prefer to ue Errsym method
    if self.Errsym.len()>0 {
      let errsym = self.Errsym;
      // lookdown stack for state with transition on Errsym
      // but that could be current state too (start at top)
      let mut k = self.stack.len(); // offset by 1 because of usize
      let mut spos = k+1;
      while k>0 && spos>k
      {
        let ksi = self.stack[k-1].si;
        erraction = self.RSM[ksi].get(errsym);
        if let None = erraction {k-=1;} else {spos=k;}
      }//while k>0
      if spos==k { self.stack.truncate(k); } // new current state revealed
      // run all reduce actions that are valid before the Errsym:
      while let Some(Reduce(ri)) = erraction // keep reducing
      {
       //self.reduce(ri); // borrow error- only need mut self.stack
              self.popped.clear();
              let rulei = &self.Rules[*ri];
              let ruleilhs = rulei.lhs; // &'static : Copy
              //let mut dummy = RuntimeParser::new(1,1);
              let val = (rulei.Ruleaction)(self); 
              let newtop = self.stack[self.stack.len()-1].si; 
              let gotonopt = self.RSM[newtop].get(ruleilhs);
              match gotonopt {
                Some(Gotonext(nsi)) => { 
                  //self.stack.push(Stackelement{si:*nsi,value:val});
                  self.stack.push(StackedItem::new(*nsi,val,self.linenum,self.column)); 
                },// goto next state after reduce
                _ => {self.abort("recovery failed"); },
              }//match
              // end reduce
       
              let tos=self.stack[self.stack.len()-1].si;
              erraction = self.RSM[tos].get(self.Errsym).clone();
      } // while let erraction is reduce
      // remaining defined action on Errsym must be shift
      if let Some(Shift(i)) = erraction { // simulate shift errsym 
          self.stack.push(StackedItem::new(*i,AT::default(),lookahead.line,lookahead.column));
          // keep lookahead until action is found that transitions from
          // current state (i). but skipping ahead without reducing
          // the error production is not a good idea.  This implementation
	  // does NOT assume that everything following the ERROR symbol is
	  // terminal.
          while let None = self.RSM[*i].get(lookahead.sym) {
            if lookahead.sym=="EOF" {break;}
            *lookahead = self.tokenizer.next_tt();
          }//while let
          // either at end of input or found action on next symbol
          erraction = self.RSM[*i].get(lookahead.sym);
      } // if shift action found down under stack
    }//errsym exists

    // at this point, if erraction is None, then Errsym failed to recover,
    // try the resynch symbol method next ...
    if iserror(&erraction) && self.resynch.len()>0 {
      while lookahead.sym!="EOF" &&
        !self.resynch.contains(lookahead.sym) {
        self.linenum = lookahead.line; self.column = lookahead.column; self.prev_position=self.position; self.position = self.tokenizer.position();
        *lookahead = self.tokenizer.next_tt();
      }//while
      if lookahead.sym!="EOF" {
        // look for state on stack that has action defined on next symbol
        self.linenum = lookahead.line; self.column = lookahead.column; self.prev_position=self.position; self.position=self.tokenizer.position();
        *lookahead = self.tokenizer.next_tt();
      }
      let mut k = self.stack.len()-1; // offset by 1 because of usize
      let mut position = 0;
      while k>0 && erraction==None
      {
         let ksi = self.stack[k-1].si;
         erraction = self.RSM[ksi].get(lookahead.sym);
         if let None=erraction {k-=1;}
      }//while k>0 && erraction==None
      match erraction {
        None => {}, // do nothing, whill shift next symbol
        _ => { self.stack.truncate(k);},//pop stack
      }//match
   }// there are resync symbols

   // at this point, if erraction is None, then resynch recovery failed too.
   // only action left is to skip ahead...
   let mut eofcx = 0;
   while iserror(&erraction) && eofcx<1 { //skip input
      self.linenum = lookahead.line; self.column = lookahead.column; self.prev_position=self.position; self.position=self.tokenizer.position();
      *lookahead = self.tokenizer.next_tt();
      if lookahead.sym=="EOF" {eofcx+=1;}
      let csi =self.stack[self.stack.len()-1].si;
      erraction = self.RSM[csi].get(lookahead.sym);
   }// skip ahead
   match erraction {
     Some(act) if eofcx<1 => Some(*act),
     _ => None,
   }//return match
  }//error_recover function

  /// resets parser, including external state
  pub fn reset(&mut self) {
    self.stack.clear();
    self.err_occurred = false;
    let mut result = AT::default();
    self.exstate = ET::default();
  }//reset

  /// Retrieves recorded error report.  This function will return an empty string
  /// if [BaseParser::set_err_report] is not called.  It will also return an
  /// empty string if there was no error
  pub fn get_err_report(&self) -> &str {
    self.err_report.as_deref().unwrap_or("")
  }

  /// When given true as argument, this option will disable the output of
  /// parser errors to stderr, and instead log them internally until retrieved
  /// with [BaseParser::get_err_report].  Each call to this function will
  /// clear the previous report and begin a new one.
  /// If the bool argument is false, it will erase and turn off error logging
  /// and print all parser errors to stderr.  This function does not affect
  /// interactive training, which uses stdio.
  pub fn set_err_report(&mut self, onof:bool) {
    if onof {self.err_report = Some(String::new());}
    else {self.err_report = None;}
  }


}//impl BaseParser 2



/////////////////////////////////////////////////////////////////////////
/////////////// new approach using more flexible trait object

/// A trait object that implements ErrReportMaker is expected by the [BaseParser::parse_core]
/// function, which implements the basic LR parsing algorithm using the
/// generated state machine.  The struct [StandardReporter] is provided as
/// the default ErrReportMaker that uses standard I/O as interface and has the
/// ability to train the parser.  But other implementations of the trait
/// can be created that use different interfaces, such as a graphical IDE.
///
/// This trait replaces [crate::ErrHandler] in the [crate::runtime_parser] module.
pub trait ErrReportMaker<'t,AT:Default,ET:Default,TT:Tokenizer<'t,AT>> // not same as error recovery
{
  fn err_reporter(&mut self, parser:&mut BaseParser<'t,AT,ET,TT>, lookahead:&TerminalToken<AT>, erropt:&Option<Stateaction>);
  fn report_err(&self, parser:&mut BaseParser<'t,AT,ET,TT>, msg:&str) { parser.report(msg) }
}// ErrReportMaker trait  // not same as RuntimeParser::ErrHandler

/*
The structure here is a bit strange.  The script file is written to in
interactive training mode and read from in script-training mode.  However,
the actual modification of the parser file is done after the training, by
the augmenter module.  Thus there's another wrapper function that's needed
besides the creation of the right kind of StandardReporter.
*/

impl<'t,AT:Default,ET:Default,TT:Tokenizer<'t,AT>> ErrReportMaker<'t,AT,ET,TT> for StandardReporter
{
  // this function will be able to write training script to file
  fn err_reporter(&mut self, parser:&mut BaseParser<'t,AT,ET,TT>, lookahead:&TerminalToken<AT>, erropt:&Option<Stateaction>)
 { 
  let mut wresult:std::io::Result<()> = Err(std::io::Error::new(std::io::ErrorKind::Other,"")); // dummy
  // known that actionop is None or Some(Error(_))
  let cstate = parser.stack[parser.stack.len()-1].si; // current state
  let mut actionopt = if let Some(act)=erropt {Some(act)} else {None};
  let lksym = &lookahead.sym[..];
  // is lookahead recognized as a grammar symbol?
  // if actionopt is NONE, check entry for ANY_ERROR            
  if parser.Symset.contains(lksym) {
     if let None=actionopt {
        actionopt = parser.RSM[cstate].get("ANY_ERROR");
     }
  }// lookahead is recognized grammar sym
  else {
     actionopt = parser.RSM[cstate].get("ANY_ERROR");
  }// lookahead is not a grammar sym
  let mut errmsg = if let Some(Error(em)) = &actionopt {
    format!("unexpected symbol '{}' on line {}, column {}: ** {} ** ..",lksym,lookahead.line,lookahead.column,em.trim())
  } else {format!("unexpected symbol '{}' on line {}, column {} .. ",lksym,lookahead.line,lookahead.column)};

  ////// augment errmsg with current line (version 0.2.6)
  let srcline = parser.tokenizer.current_line();
  if (srcline.len()>0) {
    errmsg.push_str("\n >>");
    errmsg.push_str(srcline);
    errmsg.push_str("\n");
    let mut cln = lookahead.column+2;
    while cln>0 { errmsg.push(' '); cln-=1; }
    //let mut tokenlen = srcline[cln-2..].find(char::is_whitespace).unwrap_or(1);
    let mut tokenlen = lookahead.sym.len();
    if is_alphanum(&lookahead.sym) {tokenlen = 3;}
    while tokenlen>0 { errmsg.push('^'); tokenlen-=1; }
    errmsg.push('\n');
  }// augment errmsg with current line
  
  parser.report(&errmsg);

  if self.training {          ////// Training mode
    let csym = lookahead.sym.to_owned();
    let mut inp = String::from("");    
   if let None=self.scriptinopt {  // interactive mode
   if let Some(outfd1) = &self.scriptoutopt {
    let mut outfd = outfd1;
    print!("\n>>>TRAINER: if this message is not adequate (for state {}), enter a replacement (default no change): ",cstate);
    let rrrflush = io::stdout().flush();
    if let Ok(n) = io::stdin().read_line(&mut inp) {
       if inp.len()>5 && parser.Symset.contains(lksym) {
         print!(">>>TRAINER: should this message be given for all unexpected symbols in the current state? (default yes) ");
        let rrrflush2 = io::stdout().flush();
        let mut inp2 = String::new();
        if let Ok(n) = io::stdin().read_line(&mut inp2) {
            if inp2.trim()=="no" || inp2.trim()=="No" {
               wresult = write!(outfd,"{}\t{}\t{} ::: {}\n",lookahead.line,lookahead.column,&csym,inp.trim());
               self.trained.insert((cstate,csym),inp);
            }
            else  {// insert for any error
               wresult = write!(outfd,"{}\t{}\t{} ::: {}\n",lookahead.line,lookahead.column,"ANY_ERROR",inp.trim());
               self.trained.insert((cstate,String::from("ANY_ERROR")),inp);
            }
        }// read ok
       }// unexpected symbol is grammar sym
       else if inp.len()>5 && !parser.Symset.contains(lksym) {
         wresult = write!(outfd,"{}\t{}\t{} ::: {}\n",lookahead.line,lookahead.column,"ANY_ERROR",inp.trim());
         self.trained.insert((cstate,String::from("ANY_ERROR")),inp);
       }
    }// process user response
   }}// interactive mode
   else { // training from script mode (non-interactive)
    if let Some(brfd) = &mut self.scriptinopt {
     let mut scin = brfd;
     let mut readn = 0;
     while readn < 1
     {
       inp = String::new();
       match scin.read_line(&mut inp) {
         Ok(n) if n>1 && &inp[0..1]!="#" && inp.trim().len()>0 => {readn=n;},
         Ok(n) if n>0 => { readn=0; }, // keep reading
         _ => {readn = 1; } // stop - this means End of Stream
       }//match
       if readn>1 { // read something
         let inpsplit:Vec<&str> = inp.split_whitespace().collect();
         if inpsplit.len()>4 && inpsplit[3].trim()==":::" {
           let inline = inpsplit[0].trim().parse::<usize>().unwrap();
           let incolumn = inpsplit[1].trim().parse::<usize>().unwrap();
           let insym = inpsplit[2].trim();
           if parser.linenum==inline && parser.column==incolumn {
             if &csym==insym || insym=="ANY_ERROR" {
               let posc = inp.find(":::").unwrap()+4;
               println!("\n>>>Found matching entry from training script for {}, error message: {}",insym,&inp[posc..]);
               self.trained.insert((cstate,String::from(insym)),String::from(&inp[posc..]));
             } // unexpected symbol match
           }// line/column match
         }//inpsplit check
       }// valid training line read
     }//while readn<2
   }}//training from script mode
  }//if training   //// END TRAINING MODE
  
 }// standardreporter function
}// impl ErrReportMaker for StandardReporter


/////////////////////////////////////////////////////////////
//////////////// parse_core replaced: now uses zc tokenizer
impl<'t,AT:Default,ET:Default,TT:Tokenizer<'t,AT>> BaseParser<'t,AT,ET,TT>
{
  /// This function provides a core parser that uses the LR state machine
  /// generated by rustlr.  It takes as trait objects a tokenizer and an
  /// [ErrReportMaker] object that handles the display of error messages.
  /// This function will reset the parse stack but it will not reset the
  /// Tokenizer or the *external state* of the parser.
  pub fn parse_core<R:ErrReportMaker<'t,AT,ET,TT>>(&mut self, err_handler:&mut R) -> AT
  {
    self.stack.clear();
    self.err_occurred = false;
    let mut result = AT::default();
    //self.exstate = ET::default();
    self.stack.push(StackedItem::new(0,AT::default(),0,0));
    self.stopparsing = false;
    let mut action = Stateaction::Error("");
    let mut lookahead = TerminalToken::new("EOF",AT::default(),0,0); //just init
    // nextsym() should only be called here
    if let Some(tok) = self.tokenizer.nextsym() {lookahead=tok;}
    //else {self.stopparsing=true;}

    while !self.stopparsing
    {
      let tos = self.stack.len()-1;
      self.linenum = self.stack[tos].line;
      self.column=self.stack[tos].column;
      let currentstate = self.stack[tos].si;
      let mut actionopt = self.RSM[currentstate].get(lookahead.sym);

      if actionopt.is_none() && lookahead.sym!="EOF" { // added in version 0.2.9
        actionopt = self.RSM[currentstate].get("_WILDCARD_TOKEN_");
        // added for 0.2.94:
        lookahead = self.tokenizer.transform_wildcard(lookahead);
      }

      let actclone:Option<Stateaction> = match actionopt {
        Some(a) => Some(*a),
        None => None,
      };
      if iserror(&actionopt) {  // either None or Error
        if !self.err_occurred {self.err_occurred = true;}
        
        err_handler.err_reporter(self,&lookahead,&actclone);
        
        match self.error_recover(&mut lookahead) {
          None => { self.stopparsing=true; break; }
          Some(act) => {action = act;}, // lookahead=la;},
        }//match
      }// iserror
      else { action = actclone.unwrap(); }
      match &action {
        Shift(nextstate) => {
           lookahead = self.shift(*nextstate,lookahead);
        },
        Reduce(rulei) => { self.reduce(rulei); },
        Accept => {
          self.stopparsing=true;
          if self.stack.len()>0 {result = self.stack.pop().unwrap().value;}
          else {self.err_occurred=true;}
        },
        _ => {}, // continue
      }//match action
    }// main parse loop
    return result;
  }//parse_core

  ///provided generic parsing function that reports errors on std::io. 
  pub fn parse(&mut self) -> AT
  {
    let mut stdeh = StandardReporter::new();
    self.parse_core(&mut stdeh) 
  }//parse_stdio

  ///Parses in interactive training mode with provided path to parserfile.
  ///The parser file will be modified and a training script file will be
  ///created for future retraining after grammar is modified. 
  ///
  /// When an error occurs, the parser will
    /// ask the human trainer for an appropriate error message: it will
    /// then insert an entry into its state transition table to
    /// give the same error message on future errors of the same type.
    /// If the error is caused by an unexpected token that is recognized
    /// as a terminal symbol of the grammar, the trainer can select to
    /// enter the entry 
    /// under the reserved ANY_ERROR symbol. If the unexpected token is
    /// not recognized as a grammar symbol, then the entry will always
    /// be entered under ANY_ERROR.  ANY_ERROR entries for a state will match
    /// all future unexpected symbols for that state: however, entries for
    /// valid grammar symbols will still override the generic entry.
    ///
    /// Example: with the parser for this [toy grammar](https://cs.hofstra.edu/~cscccl/rustlr_project/cpm.grammar), parse_train can run as follows:
    ///```ignore
    ///  Write something in C+- : cout << x y ;   
    ///  ERROR on line 1, column 0: unexpected symbol y ..
    ///  >>>TRAINER: is this error message adequate? If not, enter a better one: need another <<                   
    ///  >>>TRAINER: should this message be given for all unexpected symbols in the current state? (default yes) yes
    ///```
    /// (ignore the column number as the lexer for this toy language does not implement it)
    ///
    /// parse_train will then produced a [modified parser](https://cs.hofstra.edu/~cscccl/rustlr_project/cpmparser.rs) as specified
    /// by the filename (path) argument.  When the augmented parser is used, it will
    /// give a more helpful error message:
    ///```
    /// Write something in C+- : cout << x endl
    /// ERROR on line 1, column 0: unexpected symbol endl, ** need another << ** ..
    ///```
    ///
    /// parse_stdio_train calls parse_stdio, which uses stdin/stdout for user interface.
    /// Parsing in interactive training mode also produces a [training script file](http://cs.hofstra.edu/~cscccl/rustlr_project/cpmparser.rs_script.txt) which can
    /// be used to re-train a parser using [BaseParser::train_from_script]. 
    /// This is useful after a grammar is modified with extensions to a language.
  pub fn parse_train(&mut self, parserfile:&str) -> AT
    {
      let mut stdtrainer = StandardReporter::new_interactive_training(parserfile);
      let result = self.parse_core(&mut stdtrainer);
      if let Err(m) = stdtrainer.augment_training(parserfile) {
        eprintln!("Error in augmenting parser: {:?}",m)
      }

      return result;
    }//parse_stdio_train

  /// trains parser from a [training script](https://cs.hofstra.edu/~cscccl/rustlr_project/cpmparser.rs_script.txt)
  /// created by interactive training.  This
  /// is intended to be used after a grammar has been modified and the parser
  /// is regenerated with different state numbers.  It is the user's
  /// responsibility to keep consistent the parser file, script file, and sample
  /// input that was used when the script was created.  The script contains
  /// the line and column numbers of each error encountered, along with either
  /// the unexpected symbol that caused the error, or the reserved ANY_ERROR
  /// symbol if the error message is to be applied to all unexpected symbols.
  /// These entries must match, in sequence, the errors encountered during
  /// retraining - it is therefore recommended that the same tokenizer be used
  /// during retraining so that the same line/column information are given.
  /// The trainer will augment the parser (parserfile) with new Error
  /// entries, overriding any previous ones.  It is also recommended that the
  /// user examines the "load_extras" function that appears at the end of
  /// the [augmented parser](https://cs.hofstra.edu/~cscccl/rustlr_project/cpmparser.rs).
  /// The train_from_script function does not return
  /// a value, unlike [BaseParser::parse] and [BaseParser::parse_train].
  pub fn train_from_script(&mut self, parserfile:&str, scriptfile:&str)
  {
      let mut stdtrainer = StandardReporter::new_script_training(parserfile,scriptfile);
      let result = self.parse_core(&mut stdtrainer);
      if let Err(m) = stdtrainer.augment_training(parserfile) {
        eprintln!("Error in augmenting parser: {:?}",m)
      }
      if !self.err_occurred {println!("no errors encountered during parsing");}
  }//train_from_script

}// 3rd impl BaseParser
#[cfg(feature = "generator")]
fn checkboxlabel(s:&str) -> &str
{
    if s.starts_with('[') && s.ends_with(']') {s[1..s.len()-1].trim()} else {s}
}// check if label is of form [x], returns x, or s if not of this form.

// used by genlex routines
fn is_alphanum(x:&str) -> bool
{

//  let alphan = Regex::new(r"^[_a-zA-Z][_\da-zA-Z]*$").unwrap();
//  alphan.is_match(x)

  if x.len()<1 {return false};
  let mut chars = x.chars();
  let first = chars.next().unwrap();
  if !(first=='_' || first.is_alphabetic()) {return false;}
  for c in chars
  {
    if !(c=='_' || c.is_alphanumeric()) {return false;}
  }
  true
}//is_alphanum
