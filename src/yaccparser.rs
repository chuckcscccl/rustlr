//Parser generated by rustlr for grammar yacc
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
use std::rc::Rc;
use std::cell::RefCell;
use std::io::{self,Read,Write,BufReader,BufRead};
use crate::{Tokenizer,TerminalToken,BaseParser,BaseProduction,Stateaction,decode_action};
use crate::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use crate::{LC,LBox};
use crate::yacc_ast::*;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

// manually added
pub fn convert_from_yacc(srcfile:&str)
{
  let sourceopt = LexSource::new(srcfile);
  if sourceopt.is_err() {return;}
  let source = sourceopt.unwrap();

   let scanner4 = yacclexer::from_source(&source);
   let mut parser4 = make_parser(scanner4);
   let tree4= parse_with(&mut parser4);
   let result4 = tree4.unwrap_or_else(|x|{println!("Parsing errors encountered; results are partial.."); x});
   if parser4.error_occurred() {println!("\n Parser Errors Encountered.. check above");}

   let symboltable = parser4.shared_state.take();
   let rrgmr = build_rr(&result4,&symboltable);

   // derive grammar name
   let mut outgrammar = String::new();
   if let Some(pos) = srcfile.rfind(".y") {
     outgrammar = format!("{}.grammar",&srcfile[..pos]);
   }
   if outgrammar.len()==0 {   println!("{}",&rrgmr);  } //print to stdout
   else {
     let mut fd = File::create(&outgrammar).expect("Unable to open outfile file");
     let resultw = write!(fd,"{}",&rrgmr);
     if resultw.is_err() {eprintln!("Failed to write to output file");}
     else {println!("Converted grammar saved in {}",&outgrammar);}
   }// write to file
}//convert_from_yacc

///// building rustlr grammar
use yacc_decl::*;
use rhs_symbol::*;
use label::*;

// ignore all raw C code and all semantic actions as they are meaningless
// in rust anyway.  Only extract and translate the pure grammar.

pub fn build_rr<'t>(yygmr:&Yacc<'t>, symtab:&symbol_table<'t>) -> String
{
  let mut rrgmr = String::from("# Rustlr grammar converted from Yacc\n\n");
  let Yacc(_,primary{raw_declarations,yacc_declarations,rules},_) = yygmr;

  // write collected lexterminals from symbol table
  // create reverse hashmap from lexforms to names
  let mut lexhash = HashMap::with_capacity(symtab.lexterminals.len());
  // insert names for common symbols
  let syms1 = ["+","-","*","/","%","#","&","^","$","@",",",";",".","|",":"];
  let names1= ["PLUS","MINUS","STAR","SLASH","MOD","HASH","AND","HAT","DOLLAR","ATSYMBOL","COMMA","SEMICOLON","PERIOD","BAR","COLON"];
  let syms2 =["=","!","!=","==","&&","||","++","--","<",">","<=",">=","**"];
  let names2= ["EQUALS","BANG","NOTEQ","EQEQ","ANDAND","OROR","PLUSPLUS","MINUSMINUS", "LESSTHAN", "GREATERTHAN","LEQ","GEQ","STARSTAR"];
  let syms3 = ["(",")","[","]","{","}","+=","-=","*=","/=","?","\\","~","::","->"];
  let names3= ["LPAREN","RPAREN","LBRACK","RBRACK","LBRACE","RBRACE","PLUSEQ","MINUSEQ","TIMESEQ","DIVEQ","QUEST","BACKSLASH","TILDE","COLONCOLON","ARROW"];

  for i in 0..syms1.len() {lexhash.insert(syms1[i],names1[i].to_owned());}
  for i in 0..syms2.len() {lexhash.insert(syms2[i],names2[i].to_owned());}
  for i in 0..syms3.len() {lexhash.insert(syms3[i],names3[i].to_owned());}

  let mut ltcx = 0;
  for lterm in symtab.lexterminals.iter() {
    let tname = lexhash.entry(lterm).or_insert_with(||{
       let tname1 = format!("TERMINAL{}",ltcx);
       ltcx+=1;
       tname1
    });
    rrgmr.push_str(&format!("lexterminal {} {}\n",tname,lterm));
    //lexhash.insert(lterm,tname); // maps * to TERMINAL1
    //ltcx+=1;
  }//for lexterminals in symbol table
  
  // process yacc_declarations for more terminals,
  let mut precedence:i32 = 10;
  let nonassocbit:i32 = -1 - 0x40000000;
  let mut prec_table = HashMap::new();
  for decl in yacc_declarations {  //decl is of type Lbox<yacc_decl>
    match &**decl {
      lexterminal(tn,ts) => {
        rrgmr.push_str(&format!("lexterminal {} {}\n",tn,ts));
      },
      terminals(tlist) => {
        rrgmr.push_str("terminals ");
        for lbxterm in tlist.iter() {   // lbox<idnum>
          let idnum(termname,_) = **lbxterm;
//          let lower = (**lbxterm); //.to_owned();
//          lower.make_ascii_lowercase();
          rrgmr.push_str(termname); rrgmr.push(' ');
        }
        rrgmr.push('\n');
      },
      nonterminal(_, nts) => {
        rrgmr.push_str("nonterminals ");
        for lbxnt in nts { rrgmr.push_str(**lbxnt); rrgmr.push(' ');}
        rrgmr.push('\n');  
      },
      left{vs:ids} => {
        for idn in ids {  // in LBox
          let idnum(id,_) = **idn;
          prec_table.insert(id,precedence);
        }
        precedence += 10;
      },
      right{vs:ids} => {
        for idn in ids {  // in LBox
          let idnum(id,_) = **idn;
          prec_table.insert(id,-1*precedence);
        }
        precedence += 10;
      },      
      nonassoc{vs:ids} => {
        for id in ids {  // in LBox
          prec_table.insert((**id).0,nonassocbit-precedence);
        }
        precedence += 10;
      },      
      // topsym placed in symbol table by metaparser
      _ => {},
    }//match decl
  }//for each yacc_declaration
  // add nonterminals from symbol table, found on the fly by metaparser
  if symtab.nonterminals.len()>0 {
    rrgmr.push_str("nonterminals ");
    for nt in symtab.nonterminals.iter()
      { rrgmr.push_str(*nt); rrgmr.push(' ');}
    rrgmr.push('\n');
  }//symbol table nonterminals

  let mut startsymbol = symtab.topsym;
  if symtab.topsym.len()==0 {
    startsymbol=symtab.nonterminals.iter().next().expect("THIS GRAMMAR DOES NOT HAVE A NON-TERMINAL SYMBOL THAT CAN SERVE AS START SYMBOL");
  }
  rrgmr.push_str(&format!("startsymbol {}\n\n",startsymbol));

  // operator precedence and associativity
  for (sym,lev) in prec_table.iter() {
    if *lev<nonassocbit {
      rrgmr.push_str(&format!("nonassoc {} {}\n",sym,(lev-nonassocbit).abs()));
    }
    /*
    if *lev<nonassocbit { rrgmr.push_str(&format!("left {} {}\n",sym,-1*(lev-nonassocbit))); }
    */
    else if *lev>0 { rrgmr.push_str(&format!("left {} {}\n",sym,lev)); }
    else if *lev<0 { rrgmr.push_str(&format!("right {} {}\n",sym,-1*lev)); }
  }//precedence
  rrgmr.push('\n');
  
  // now for rules:
  for rule in rules {  // rule is LBox<grammar_rules>
    rrgmr.push_str(&format!("{} ==>\n",rule.lhs));
      let mut rhscount = 0;
      for rhside in &rule.rhsides {  //LBox<rhs>
        if rhscount>0 && rhscount<rule.rhsides.len() {
          rrgmr.push_str("        | ");
        } else {rrgmr.push_str("          ");}
        let rhs(rsymunits,_) = &**rhside;
        for rsymu in rsymunits {
          let rhsunit(_,rsym) = &**rsymu;
          match rsym {  //rsym is a rhs_symbol enum
            ID(name,nlabel) => {
              rrgmr.push_str(name);
              nlabel.as_deref().map(|lab|{rrgmr.push_str(&format!(":{}",&getlabel(lab)));});
            },
            LEXCHAR{t:n} | LEXSTR{t:n} => {
              let nname = lexhash.get(n).expect("UNEXPECTED ERROR: Grammar's Symbol Table Corrupted");
              rrgmr.push_str(nname);
            },
            _ => {},
          }//match
          rrgmr.push(' ');
        } //for each rsymunit
        rhscount+=1;
        rrgmr.push('\n');
      }//for each rhs of a rule
      rrgmr.push_str("        <==\n");
  }//for each set of rules for a nonterminal
  rrgmr.push_str("\nEOF\n");
  
  rrgmr
}//build_rr from yy


// decipher label
fn getlabel(lab:&label) -> String
{
  match lab {
    simple(n) => String::from(*n),
    boxed(n) => format!("[{}]",n),
    parened(ns) => {
      let mut vs =String::new();
      for nv in ns {
        vs.push_str(&format!("{},",**nv));
      }
      format!("({})",&vs)
    },
    _ => String::new(),
  }
}//getlabel


static SYMBOLS:[&'static str;76] = ["_WILDCARD_TOKEN_","ACTION","ADDITIONALS","RAWDECL","ID","LEXCHAR","LEXSTR","NUMBER","PERTYPE","PERTOKEN","PERLEFT","PERRIGHT","PERNONASSOC","PERSTART","PERPERCENT","LBRACE","RBRACE","LPAREN","RPAREN","LBRACK","RBRACK","LANGLE","RANGLE","PERCENT","COLON","SEMICOLON","COMMA","BAR","STAR","PLUS","QUEST","PERLBRACK","PERRBRACK","AT","DOLLAR","TWODOLLARS","DASH","union","yacc_decl","Yacc","grammar_rules","rhs_symbol","rhs","label","tag","idnum","primary","rhsunit","semaction","semcontent","semstart","unionset","NEWRENT_1_0","NEWRENT_3_1","NEWRENT_5_2","NEWSEQNT_8_0","NEWRENT_9_1","NEWRENT_11_2","NEWRENT_13_3","NEWRENT_16_0","NEWRENT_26_0","NEWSEQNT_29_0","NEWRENT_30_1","NEWRENT_33_0","NEWSEQNT_36_0","NEWRENT_37_1","NEWSEPNT_44_0","NEWRENT_46_1","NEWRENT_49_0","NEWRENT_52_0","NEWRENT_57_0","NEWSEPNT_60_0","START","EOF","NEWDELAYNT_NEWRENT_9_1_46","NEWDELAYNT_NEWRENT_1_0_53"];

static TABLE:[u64;449] = [317833281537,55835557888,12891127808,98790670336,197574066177,322128445441,236228837377,163209936897,42950590464,47245426688,38655754240,34360983552,51540918272,167503921153,227639230465,844738462744579,2251808404406274,2252113347084290,2815063300636674,3377892998971393,3377953129037825,3377716905443328,3940903082393601,3940666858864640,3940842952392705,4222141835313152,4503853035290625,4503792905814017,4503616812220416,4785233522524160,4785293652000769,5066588235694082,5066605415563266,5066592530661378,5066601120595970,5066609710530562,5066648365236226,5066596825628674,5066583940726786,5348286552080385,5348041739337730,5348290846916609,5348213537439745,5348114753323008,5629692812656641,5629752942788609,5629516719128576,5910991692627968,5911232210731009,6192466669338626,6473941645852672,6755416622956546,7036968908750848,7318366576246786,7599867322499074,7599875912433666,7599884502368258,7599871617466370,7599923157073922,7599858732564482,7599841552957440,7599880207400962,7599863027531778,7881342299275266,7881398133850114,7881355184177154,7881346594242562,7881359479144450,7881350889209858,7881316529471490,7881333709340674,7881338004307970,8162825865986050,8162830160953346,8162817276051458,8162873110626306,8162834455920642,8162791506247682,8162808686116866,8162812981084162,8162821571018754,8725767227965442,8725780112867330,8725758638030850,8725771522932738,8725775817900034,8725784407834626,8725823062540290,8725762932998146,9007259384610818,9007207845003266,9007216434937858,9007512787681282,9288777313026048,9851684314808322,9851641365135362,9851632775200770,9851937717878786,10133116344860674,10133279552765953,10133215129108482,10133206539173890,10133120639827970,10133124934795266,10133404106752001,10133163589500930,10133395516751873,10414690105622530,10414776004444161,10414638565556224,10414599911309314,10414780299542529,10414681515687938,10414591321374722,10414866198691841,10414595616342018,10696165083578368,10696156493578240,10977631469830146,10977640059764738,11259020546408448,11259115035885570,11259024841506816,11259175165296641,11259106445950978,11259016251637760,11540495523446786,11540491228479490,11540538473119746,11540499818414082,11540590012727298,11540581422792706,11822017745059842,11822249672441857,11821949025583106,12103531376017410,12103449771638786,12103441181704194,12103539965952002,12103445476671490,12385109431746561,12384898978283520,12384967697694720,12666373955584002,12666395430486018,12666481329831938,12666489919766530,12666391135518722,12666399725453314,12666442675060738,12947917651705858,12947848932229122,13229392628678658,13229323909201922,13510914848784386,13510824654471170,13510863309176834,13510816064536578,13510906258849794,13510820359503874,13792291041837058,13792338286477314,13792389826084866,13792381236150274,13792295336804354,13792299631771650,14073813262663682,14073766018023426,14073770312990722,14073774607958018,14073856212336642,14073864802271234,14355326894931968,14355502988525569,14355331188850690,14355240994537474,14355339778785282,14355245289504770,14355249584472066,14355498693689345,14355288239177730,14636720266084354,14636715971117058,14636763215757314,14636814755364866,14636724561051650,14636806165430274,14918246783909888,14918255373713408,14918358452994049,14918190949138432,15199670219702274,15199674514669570,15199713169375234,15199764708982786,15199665924734978,15199756119048194,15481145196609538,15481231095955458,15481188146282498,15481149491576834,15481140901642242,15481239685890050,15762615879532544,16044095149703170,16044099444670466,16044138099376130,16044189638983682,16044090854735874,16044181049049090,16325832121057281,16325565833150464,16607109529206784,16888605979574274,16888520080228354,16888515785261058,16888614569508866,16888524375195650,16888563029901314,17170050891776002,17170261346287617,17170085252694016,17451560228093954,17451525868355586,17733000846442496,18014475821973506,18014415693676544,18295989453127682,18295980863193090,18295894963847170,18295899258814466,18295890668879874,18295937913520130,18577460135002114,18577425775263746,18858840623349762,18858832033415170,18859136976093186,18858883573022722,19140594771492865,19140319894568962,19140414383849474,19140362844241922,19140324189536258,19140315599601666,19140405793914882,19140478809473025,19421889361149954,19421880771215362,19703252669431808,19984727642996738,20266241274347522,20266258454216706,20266297108922370,20266236979380226,20266245569314818,20266232684412930,20266254159249410,20266249864282114,20547724840730626,20547729135697922,20547716250796034,20547707660861442,20547720545763330,20547733430665218,20547711955828738,20547772085370882,20829199817179138,20829165461504000,20829182637309954,20829341555228673,20829195522211842,20829247061819394,20829191227244546,20829208407113730,20829186932277250,20829204112146434,21110661909053442,21110666204020738,21110722038595586,21110640434216962,21110674793955330,21110670498988034,21110657614086146,21110683383889922,21110679088922626,21392145476812802,21392132591910914,21392158361714690,21392368818192385,21392136886878210,21392149771780098,21392128299958272,21392154066747394,21392197016420354,21392141181845506,21392124005122048,21392115412041730,21673633338425346,21673607568621570,21673616158556162,21673671993131010,21673629043458050,21673590388752386,21673624748490754,21673603276668928,21673843794903041,21673611863588866,21673620453523458,21955146968793090,21955086839250946,21955095429185538,21955099724152834,21955082544283650,21955104019120130,21955108314087426,21955091134218242,21955065364414466,22236540342239234,22236557522108418,22236578996944898,22236566112043010,22236561817075714,22236583291912194,22236574701977602,22236570407010306,22236621946617858,22518045383589890,22518096923197442,22518049678557186,22518053973524482,22518032498688002,22518058268491778,22518041088622594,22518015318818818,22518036793655298,22799524654350338,22799520359383042,22799571898990594,22799516064415746,22799533244284930,22799528949317634,22799507474481154,22799511769448450,23080986746290178,23081141368913921,23081046875832322,23080965275189248,23081003926159362,23081008221126658,23080982451322882,23080999631192066,23080991041257474,23080995336224770,23362478902935554,23362470313000962,23362440251899904,23362474607968258,23362466018033666,23362457428099074,23362483197902850,23362461723066370,23362521852608514,23362616345624577,23643949584744450,23643940994809858,23643958174679042,23643915228610560,23643996829384706,23643936699842562,23643953879711746,23643932404875266,23644091322335233,23643945289777154,23925686557212674,23925381614534658,23925433154142210,24206860888244224,24207011207053313,24206882358099968,24207170125561857,24206899538034688,24207045571706881,24206946782478336,24206886652870656,24206895242543104,24206903832674304,24206890947706880,24207075636346881,24488331564482562,24488383103893504,24488636507160578,24488567792730113,24770047064473601,24770111484002306,24769806541127680,25051586464120834,25332808039792640,25614283014537218,25614386091458561,25614265831260160,25614270126096384,25614261536423936,25614321666031616,25614257241653248,25614274421587968,25614278716227584,26177486370832386,26177232967761922,26177181428154370,26458746596163584,26458699351719936,26458695056228352,26458686466555904,26458682171785216,26458811021590529,26458703646359552,26458707944734722,26458690761392128,26740157148495872,26740170032939008,26740350426939393,26740174328430592,26740285997449217,26740165738102784,26740221572874240,26740178623070208,26740161443266560,27021614946254848,27021769565011969,27021829698813953,27303081335324674,27303386278002690,27303089922965504,27303244541919233,27303132874932226,27584564904001536,27584706636087296,27584766765563905,27866177319731200,28147514857553920,28429024187908098,28428985533202434,28429015597973506,28429019892940802,28429007008038914,28429028482875394,28429071432548354,28429011303006210,];


fn _rrsemaction_0_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut raw_declarations:Option<&'lt str>, mut yacc_declarations:Vec<LC<yacc_decl<'lt>>>, mut _item2_:(), mut rules:Vec<LC<grammar_rules<'lt>>>) -> primary<'lt> { parser.shared_state.borrow_mut().skip = true;   primary {raw_declarations:raw_declarations, yacc_declarations:yacc_declarations, rules:rules, } }

fn _rrsemaction_1_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> Option<&'lt str> {  None }

fn _rrsemaction_2_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str) -> Option<&'lt str> {  Some(_item0_) }

fn _rrsemaction_3_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:yacc_decl<'lt>) -> Vec<LC<yacc_decl<'lt>>> {  vec![parser.lc(0,_item0_)] }

fn _rrsemaction_4_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Vec<LC<yacc_decl<'lt>>>, mut _item1_:yacc_decl<'lt>) -> Vec<LC<yacc_decl<'lt>>> {  _item0_.push(parser.lc(1,_item1_)); _item0_ }

fn _rrsemaction_5_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:grammar_rules<'lt>) -> Vec<LC<grammar_rules<'lt>>> {  vec![parser.lc(0,_item0_)] }

fn _rrsemaction_6_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Vec<LC<grammar_rules<'lt>>>, mut _item1_:grammar_rules<'lt>) -> Vec<LC<grammar_rules<'lt>>> {  _item0_.push(parser.lc(1,_item1_)); _item0_ }

fn _rrsemaction_7_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Option<LBox<NEWSEQNT_8_0<'lt>>>, mut _item1_:primary<'lt>, mut _item2_:(), mut _item3_:Option<&'lt str>) -> Yacc<'lt> {  Yacc(_item0_,_item1_,_item3_,) }

fn _rrsemaction_8_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:&'lt str, mut _item2_:(), mut _item3_:&'lt str) -> NEWSEQNT_8_0<'lt> {  NEWSEQNT_8_0(_item1_,_item3_,) }

fn _rrsemaction_9_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> Option<LBox<NEWSEQNT_8_0<'lt>>> {  None }

fn _rrsemaction_10_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:NEWSEQNT_8_0<'lt>) -> Option<LBox<NEWSEQNT_8_0<'lt>>> {  Some(parser.lbx(0,_item0_)) }

fn _rrsemaction_11_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> () { <()>::default()}

fn _rrsemaction_12_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:()) -> () { <()>::default()}

fn _rrsemaction_13_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> Option<&'lt str> {  None }

fn _rrsemaction_14_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str) -> Option<&'lt str> {  Some(_item0_) }

fn _rrsemaction_15_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:Vec<LC<idnum<'lt>>>) -> yacc_decl<'lt> {  yacc_decl::terminals(_item1_) }

fn _rrsemaction_16_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:idnum<'lt>) -> Vec<LC<idnum<'lt>>> {  vec![parser.lc(0,_item0_)] }

fn _rrsemaction_17_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Vec<LC<idnum<'lt>>>, mut _item1_:idnum<'lt>) -> Vec<LC<idnum<'lt>>> {  _item0_.push(parser.lc(1,_item1_)); _item0_ }

fn _rrsemaction_18_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:&'lt str, mut _item2_:&'lt str) -> yacc_decl<'lt> {  yacc_decl::lexterminal(_item1_,_item2_) }

fn _rrsemaction_19_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut s:&'lt str) -> yacc_decl<'lt> { parser.shared_state.borrow_mut().topsym=s;   yacc_decl::topsym{s:s} }

fn _rrsemaction_20_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut vs:Vec<LC<idnum<'lt>>>) -> yacc_decl<'lt> {  yacc_decl::left{vs:vs} }

fn _rrsemaction_21_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut vs:Vec<LC<idnum<'lt>>>) -> yacc_decl<'lt> {  yacc_decl::right{vs:vs} }

fn _rrsemaction_22_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut vs:Vec<LC<idnum<'lt>>>) -> yacc_decl<'lt> {  yacc_decl::nonassoc{vs:vs} }

fn _rrsemaction_23_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:unionset, mut _item2_:&'lt str) -> yacc_decl<'lt> { parser.shared_state.borrow_mut().skip_match=false;   yacc_decl::uniondec(_item1_,_item2_) }

fn _rrsemaction_24_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:()) -> unionset { parser.shared_state.borrow_mut().skip_match=true;   unionset() }

fn _rrsemaction_25_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:tag<'lt>, mut _item2_:Vec<LC<&'lt str>>) -> yacc_decl<'lt> {  yacc_decl::nonterminal(_item1_.0,_item2_) }

fn _rrsemaction_26_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str) -> Vec<LC<&'lt str>> {  vec![parser.lc(0,_item0_)] }

fn _rrsemaction_27_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Vec<LC<&'lt str>>, mut _item1_:&'lt str) -> Vec<LC<&'lt str>> {  _item0_.push(parser.lc(1,_item1_)); _item0_ }

fn _rrsemaction_28_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Option<LBox<&'lt str>>) -> tag<'lt> {  tag(_item0_,) }

fn _rrsemaction_29_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:&'lt str, mut _item2_:()) -> &'lt str {  _item1_ }

fn _rrsemaction_30_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> Option<LBox<&'lt str>> {  None }

fn _rrsemaction_31_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str) -> Option<LBox<&'lt str>> {  Some(parser.lbx(0,_item0_)) }

fn _rrsemaction_32_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str, mut _item1_:Option<u32>) -> idnum<'lt> {  idnum(_item0_,_item1_,) }

fn _rrsemaction_33_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> Option<u32> {  None }

fn _rrsemaction_34_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:u32) -> Option<u32> {  Some(_item0_) }

fn _rrsemaction_35_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str, mut _item1_:Option<LBox<label<'lt>>>) -> rhs_symbol<'lt> {  rhs_symbol::ID(_item0_,_item1_) }

fn _rrsemaction_36_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:label<'lt>) -> label<'lt> {  _item1_ }

fn _rrsemaction_37_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> Option<LBox<label<'lt>>> {  None }

fn _rrsemaction_38_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:label<'lt>) -> Option<LBox<label<'lt>>> {  Some(parser.lbx(0,_item0_)) }

fn _rrsemaction_39_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut t:&'lt str) -> rhs_symbol<'lt> { parser.shared_state.borrow_mut().lexterminals.insert(t);
    rhs_symbol::LEXCHAR{t:t} }

fn _rrsemaction_40_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut t:&'lt str) -> rhs_symbol<'lt> { parser.shared_state.borrow_mut().lexterminals.insert(t);
    rhs_symbol::LEXSTR{t:t} }

fn _rrsemaction_41_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str) -> label<'lt> {  label::simple(_item0_) }

fn _rrsemaction_42_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:&'lt str, mut _item2_:()) -> label<'lt> {  label::boxed(_item1_) }

fn _rrsemaction_43_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:Vec<LC<&'lt str>>, mut _item2_:(), mut _item3_:()) -> label<'lt> {  label::parened(_item1_) }

fn _rrsemaction_44_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str) -> Vec<LC<&'lt str>> {  vec![parser.lc(0,_item0_)] }

fn _rrsemaction_45_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Vec<LC<&'lt str>>, mut _item1_:(), mut _item2_:&'lt str) -> Vec<LC<&'lt str>> {  _item0_.push(parser.lc(2,_item2_)); _item0_ }

fn _rrsemaction_46_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> () { <()>::default()}

fn _rrsemaction_47_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:()) -> () { <()>::default()}

fn _rrsemaction_48_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Option<LBox<semaction<'lt>>>, mut _item1_:rhs_symbol<'lt>) -> rhsunit<'lt> {  rhsunit(_item0_,_item1_,) }

fn _rrsemaction_49_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> Option<LBox<semaction<'lt>>> {  None }

fn _rrsemaction_50_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:semaction<'lt>) -> Option<LBox<semaction<'lt>>> {  Some(parser.lbx(0,_item0_)) }

fn _rrsemaction_51_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Vec<LC<rhsunit<'lt>>>, mut _item1_:Option<LBox<semaction<'lt>>>) -> rhs<'lt> {  rhs(_item0_,_item1_,) }

fn _rrsemaction_52_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> Vec<LC<rhsunit<'lt>>> {  Vec::new() }

fn _rrsemaction_53_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Vec<LC<rhsunit<'lt>>>, mut _item1_:rhsunit<'lt>) -> Vec<LC<rhsunit<'lt>>> {  _item0_.push(parser.lc(1,_item1_)); _item0_ }

fn _rrsemaction_54_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str) -> semcontent<'lt> {  semcontent::_WILDCARD_TOKEN_(_item0_) }

fn _rrsemaction_55_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:()) -> semcontent<'lt> {  semcontent::RBRACE }

fn _rrsemaction_56_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:(), mut _item1_:Vec<LC<semcontent<'lt>>>, mut _item2_:()) -> semaction<'lt> {  semaction(_item1_,) }

fn _rrsemaction_57_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>) -> Vec<LC<semcontent<'lt>>> {  Vec::new() }

fn _rrsemaction_58_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Vec<LC<semcontent<'lt>>>, mut _item1_:semcontent<'lt>) -> Vec<LC<semcontent<'lt>>> {  _item0_.push(parser.lc(1,_item1_)); _item0_ }

fn _rrsemaction_59_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut lhs:&'lt str, mut _item1_:(), mut rhsides:Vec<LC<rhs<'lt>>>, mut _item3_:()) -> grammar_rules<'lt> { let mut symtable =parser.shared_state.borrow_mut();
  symtable.nonterminals.insert(lhs);
  if symtable.topsym.len()==0 {symtable.topsym=lhs;}
    grammar_rules {lhs:lhs, rhsides:rhsides, } }

fn _rrsemaction_60_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:rhs<'lt>) -> Vec<LC<rhs<'lt>>> {  vec![parser.lc(0,_item0_)] }

fn _rrsemaction_61_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Vec<LC<rhs<'lt>>>, mut _item1_:(), mut _item2_:rhs<'lt>) -> Vec<LC<rhs<'lt>>> {  _item0_.push(parser.lc(2,_item2_)); _item0_ }

fn _rrsemaction_62_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:Yacc<'lt>, mut _item1_:(), mut _item2_:(), mut _item3_:(), mut _item4_:()) -> () { <()>::default()}

fn _rrsemaction_63_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:NEWSEQNT_8_0<'lt>, mut _item_del1_63_10_:primary<'lt>) -> (Option<LBox<NEWSEQNT_8_0<'lt>>>,primary<'lt>,) {  let _delvar_74_0_ = _rrsemaction_10_(parser,_item0_); (_delvar_74_0_,_item_del1_63_10_,) }

fn _rrsemaction_64_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item_del0_64_9_:primary<'lt>) -> (Option<LBox<NEWSEQNT_8_0<'lt>>>,primary<'lt>,) {  let _delvar_74_0_ = _rrsemaction_9_(parser); (_delvar_74_0_,_item_del0_64_9_,) }

fn _rrsemaction_65_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _delayitem0_7_83:(Option<LBox<NEWSEQNT_8_0<'lt>>>,primary<'lt>,), mut _item2_:(), mut _item3_:Option<&'lt str>) -> Yacc<'lt> {  _rrsemaction_7_(parser,_delayitem0_7_83.0,_delayitem0_7_83.1,_item2_,_item3_) }

fn _rrsemaction_66_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut yacc_declarations:Vec<LC<yacc_decl<'lt>>>) -> (Option<&'lt str>,Vec<LC<yacc_decl<'lt>>>,) {  let _delvar_75_0_ = _rrsemaction_1_(parser); (_delvar_75_0_,yacc_declarations,) }

fn _rrsemaction_67_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _item0_:&'lt str, mut yacc_declarations:Vec<LC<yacc_decl<'lt>>>) -> (Option<&'lt str>,Vec<LC<yacc_decl<'lt>>>,) {  let _delvar_75_0_ = _rrsemaction_2_(parser,_item0_); (_delvar_75_0_,yacc_declarations,) }

fn _rrsemaction_68_<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>, mut _delayitem0_0_88:(Option<&'lt str>,Vec<LC<yacc_decl<'lt>>>,), mut _item1_:(), mut rules:Vec<LC<grammar_rules<'lt>>>) -> primary<'lt> {  _rrsemaction_0_(parser,_delayitem0_0_88.0,_delayitem0_0_88.1,_item1_,rules) }

pub fn make_parser<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(tk:TT) -> BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>
{
 let mut parser1:BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT> = BaseParser::new(69,102,tk);
 let mut rule;
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("primary");
 rule.Ruleaction = |parser|{ let mut rules = if let RetTypeEnum::Enumvariant_54(_rr_54)=parser.popstack().value { _rr_54 } else {<Vec<LC<grammar_rules<'lt>>>>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut yacc_declarations = if let RetTypeEnum::Enumvariant_77(_rr_77)=parser.popstack().value { _rr_77 } else {<Vec<LC<yacc_decl<'lt>>>>::default()}; let mut raw_declarations = if let RetTypeEnum::Enumvariant_71(_rr_71)=parser.popstack().value { _rr_71 } else {<Option<&'lt str>>::default()};  RetTypeEnum::Enumvariant_61(_rrsemaction_0_(parser,raw_declarations,yacc_declarations,_item2_,rules)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_1_0");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_71(_rrsemaction_1_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_1_0");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_71(_rrsemaction_2_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_3_1");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_58(_rr_58)=parser.popstack().value { _rr_58 } else {<yacc_decl<'lt>>::default()};  RetTypeEnum::Enumvariant_77(_rrsemaction_3_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_3_1");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_58(_rr_58)=parser.popstack().value { _rr_58 } else {<yacc_decl<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_77(_rr_77)=parser.popstack().value { _rr_77 } else {<Vec<LC<yacc_decl<'lt>>>>::default()};  RetTypeEnum::Enumvariant_77(_rrsemaction_4_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_5_2");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_64(_rr_64)=parser.popstack().value { _rr_64 } else {<grammar_rules<'lt>>::default()};  RetTypeEnum::Enumvariant_54(_rrsemaction_5_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_5_2");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_64(_rr_64)=parser.popstack().value { _rr_64 } else {<grammar_rules<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_54(_rr_54)=parser.popstack().value { _rr_54 } else {<Vec<LC<grammar_rules<'lt>>>>::default()};  RetTypeEnum::Enumvariant_54(_rrsemaction_6_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("Yacc");
 rule.Ruleaction = |parser|{ let mut _item3_ = if let RetTypeEnum::Enumvariant_71(_rr_71)=parser.popstack().value { _rr_71 } else {<Option<&'lt str>>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_61(_rr_61)=parser.popstack().value { _rr_61 } else {<primary<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_70(_rr_70)=parser.popstack().value { _rr_70 } else {<Option<LBox<NEWSEQNT_8_0<'lt>>>>::default()};  RetTypeEnum::Enumvariant_0(_rrsemaction_7_(parser,_item0_,_item1_,_item2_,_item3_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWSEQNT_8_0");
 rule.Ruleaction = |parser|{ let mut _item3_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_62(_rrsemaction_8_(parser,_item0_,_item1_,_item2_,_item3_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_9_1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_70(_rrsemaction_9_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_9_1");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_62(_rr_62)=parser.popstack().value { _rr_62 } else {<NEWSEQNT_8_0<'lt>>::default()};  RetTypeEnum::Enumvariant_70(_rrsemaction_10_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_11_2");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_76(_rrsemaction_11_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_11_2");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_76(_rrsemaction_12_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_13_3");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_71(_rrsemaction_13_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_13_3");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_71(_rrsemaction_14_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("yacc_decl");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_53(_rr_53)=parser.popstack().value { _rr_53 } else {<Vec<LC<idnum<'lt>>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_58(_rrsemaction_15_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_16_0");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_49(_rr_49)=parser.popstack().value { _rr_49 } else {<idnum<'lt>>::default()};  RetTypeEnum::Enumvariant_53(_rrsemaction_16_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_16_0");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_49(_rr_49)=parser.popstack().value { _rr_49 } else {<idnum<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_53(_rr_53)=parser.popstack().value { _rr_53 } else {<Vec<LC<idnum<'lt>>>>::default()};  RetTypeEnum::Enumvariant_53(_rrsemaction_17_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("yacc_decl");
 rule.Ruleaction = |parser|{ let mut _item2_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_58(_rrsemaction_18_(parser,_item0_,_item1_,_item2_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("yacc_decl");
 rule.Ruleaction = |parser|{ let mut s = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_58(_rrsemaction_19_(parser,_item0_,s)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("yacc_decl");
 rule.Ruleaction = |parser|{ let mut vs = if let RetTypeEnum::Enumvariant_53(_rr_53)=parser.popstack().value { _rr_53 } else {<Vec<LC<idnum<'lt>>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_58(_rrsemaction_20_(parser,_item0_,vs)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("yacc_decl");
 rule.Ruleaction = |parser|{ let mut vs = if let RetTypeEnum::Enumvariant_53(_rr_53)=parser.popstack().value { _rr_53 } else {<Vec<LC<idnum<'lt>>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_58(_rrsemaction_21_(parser,_item0_,vs)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("yacc_decl");
 rule.Ruleaction = |parser|{ let mut vs = if let RetTypeEnum::Enumvariant_53(_rr_53)=parser.popstack().value { _rr_53 } else {<Vec<LC<idnum<'lt>>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_58(_rrsemaction_22_(parser,_item0_,vs)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("yacc_decl");
 rule.Ruleaction = |parser|{ let mut _item2_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_60(_rr_60)=parser.popstack().value { _rr_60 } else {<unionset>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_58(_rrsemaction_23_(parser,_item0_,_item1_,_item2_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("unionset");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_60(_rrsemaction_24_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("yacc_decl");
 rule.Ruleaction = |parser|{ let mut _item2_ = if let RetTypeEnum::Enumvariant_65(_rr_65)=parser.popstack().value { _rr_65 } else {<Vec<LC<&'lt str>>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_57(_rr_57)=parser.popstack().value { _rr_57 } else {<tag<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_58(_rrsemaction_25_(parser,_item0_,_item1_,_item2_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_26_0");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_65(_rrsemaction_26_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_26_0");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_65(_rr_65)=parser.popstack().value { _rr_65 } else {<Vec<LC<&'lt str>>>::default()};  RetTypeEnum::Enumvariant_65(_rrsemaction_27_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("tag");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_59(_rr_59)=parser.popstack().value { _rr_59 } else {<Option<LBox<&'lt str>>>::default()};  RetTypeEnum::Enumvariant_57(_rrsemaction_28_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWSEQNT_29_0");
 rule.Ruleaction = |parser|{ let mut _item2_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_72(_rrsemaction_29_(parser,_item0_,_item1_,_item2_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_30_1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_59(_rrsemaction_30_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_30_1");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_59(_rrsemaction_31_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("idnum");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_63(_rr_63)=parser.popstack().value { _rr_63 } else {<Option<u32>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_49(_rrsemaction_32_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_33_0");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_63(_rrsemaction_33_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_33_0");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_9(_rr_9)=parser.popstack().value { _rr_9 } else {<u32>::default()};  RetTypeEnum::Enumvariant_63(_rrsemaction_34_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("rhs_symbol");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_73(_rr_73)=parser.popstack().value { _rr_73 } else {<Option<LBox<label<'lt>>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_66(_rrsemaction_35_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWSEQNT_36_0");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_75(_rr_75)=parser.popstack().value { _rr_75 } else {<label<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_75(_rrsemaction_36_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_37_1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_73(_rrsemaction_37_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_37_1");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_75(_rr_75)=parser.popstack().value { _rr_75 } else {<label<'lt>>::default()};  RetTypeEnum::Enumvariant_73(_rrsemaction_38_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("rhs_symbol");
 rule.Ruleaction = |parser|{ let mut t = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_66(_rrsemaction_39_(parser,t)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("rhs_symbol");
 rule.Ruleaction = |parser|{ let mut t = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_66(_rrsemaction_40_(parser,t)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("label");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_75(_rrsemaction_41_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("label");
 rule.Ruleaction = |parser|{ let mut _item2_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_75(_rrsemaction_42_(parser,_item0_,_item1_,_item2_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("label");
 rule.Ruleaction = |parser|{ let mut _item3_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_65(_rr_65)=parser.popstack().value { _rr_65 } else {<Vec<LC<&'lt str>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_75(_rrsemaction_43_(parser,_item0_,_item1_,_item2_,_item3_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWSEPNT_44_0");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_65(_rrsemaction_44_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWSEPNT_44_0");
 rule.Ruleaction = |parser|{ let mut _item2_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_65(_rr_65)=parser.popstack().value { _rr_65 } else {<Vec<LC<&'lt str>>>::default()};  RetTypeEnum::Enumvariant_65(_rrsemaction_45_(parser,_item0_,_item1_,_item2_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_46_1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_76(_rrsemaction_46_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_46_1");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_76(_rrsemaction_47_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("rhsunit");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_66(_rr_66)=parser.popstack().value { _rr_66 } else {<rhs_symbol<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_68(_rr_68)=parser.popstack().value { _rr_68 } else {<Option<LBox<semaction<'lt>>>>::default()};  RetTypeEnum::Enumvariant_69(_rrsemaction_48_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_49_0");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_68(_rrsemaction_49_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_49_0");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_48(_rr_48)=parser.popstack().value { _rr_48 } else {<semaction<'lt>>::default()};  RetTypeEnum::Enumvariant_68(_rrsemaction_50_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("rhs");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_68(_rr_68)=parser.popstack().value { _rr_68 } else {<Option<LBox<semaction<'lt>>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_79(_rr_79)=parser.popstack().value { _rr_79 } else {<Vec<LC<rhsunit<'lt>>>>::default()};  RetTypeEnum::Enumvariant_74(_rrsemaction_51_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_52_0");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_79(_rrsemaction_52_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_52_0");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_69(_rr_69)=parser.popstack().value { _rr_69 } else {<rhsunit<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_79(_rr_79)=parser.popstack().value { _rr_79 } else {<Vec<LC<rhsunit<'lt>>>>::default()};  RetTypeEnum::Enumvariant_79(_rrsemaction_53_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("semcontent");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_78(_rrsemaction_54_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("semcontent");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_78(_rrsemaction_55_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("semaction");
 rule.Ruleaction = |parser|{ let mut _item2_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_52(_rr_52)=parser.popstack().value { _rr_52 } else {<Vec<LC<semcontent<'lt>>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()};  RetTypeEnum::Enumvariant_48(_rrsemaction_56_(parser,_item0_,_item1_,_item2_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_57_0");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_52(_rrsemaction_57_(parser)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWRENT_57_0");
 rule.Ruleaction = |parser|{ let mut _item1_ = if let RetTypeEnum::Enumvariant_78(_rr_78)=parser.popstack().value { _rr_78 } else {<semcontent<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_52(_rr_52)=parser.popstack().value { _rr_52 } else {<Vec<LC<semcontent<'lt>>>>::default()};  RetTypeEnum::Enumvariant_52(_rrsemaction_58_(parser,_item0_,_item1_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("grammar_rules");
 rule.Ruleaction = |parser|{ let mut _item3_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut rhsides = if let RetTypeEnum::Enumvariant_56(_rr_56)=parser.popstack().value { _rr_56 } else {<Vec<LC<rhs<'lt>>>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut lhs = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_64(_rrsemaction_59_(parser,lhs,_item1_,rhsides,_item3_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWSEPNT_60_0");
 rule.Ruleaction = |parser|{ let mut _item0_ = if let RetTypeEnum::Enumvariant_74(_rr_74)=parser.popstack().value { _rr_74 } else {<rhs<'lt>>::default()};  RetTypeEnum::Enumvariant_56(_rrsemaction_60_(parser,_item0_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWSEPNT_60_0");
 rule.Ruleaction = |parser|{ let mut _item2_ = if let RetTypeEnum::Enumvariant_74(_rr_74)=parser.popstack().value { _rr_74 } else {<rhs<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_56(_rr_56)=parser.popstack().value { _rr_56 } else {<Vec<LC<rhs<'lt>>>>::default()};  RetTypeEnum::Enumvariant_56(_rrsemaction_61_(parser,_item0_,_item1_,_item2_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item4_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item3_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_rr_0)=parser.popstack().value { _rr_0 } else {<Yacc<'lt>>::default()};  RetTypeEnum::Enumvariant_76(_rrsemaction_62_(parser,_item0_,_item1_,_item2_,_item3_,_item4_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWDELAYNT_NEWRENT_9_1_46");
 rule.Ruleaction = |parser|{ let mut _item_del1_63_10_ = if let RetTypeEnum::Enumvariant_61(_rr_61)=parser.popstack().value { _rr_61 } else {<primary<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_62(_rr_62)=parser.popstack().value { _rr_62 } else {<NEWSEQNT_8_0<'lt>>::default()};  RetTypeEnum::Enumvariant_82(_rrsemaction_63_(parser,_item0_,_item_del1_63_10_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWDELAYNT_NEWRENT_9_1_46");
 rule.Ruleaction = |parser|{ let mut _item_del0_64_9_ = if let RetTypeEnum::Enumvariant_61(_rr_61)=parser.popstack().value { _rr_61 } else {<primary<'lt>>::default()};  RetTypeEnum::Enumvariant_82(_rrsemaction_64_(parser,_item_del0_64_9_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("Yacc");
 rule.Ruleaction = |parser|{ let mut _item3_ = if let RetTypeEnum::Enumvariant_71(_rr_71)=parser.popstack().value { _rr_71 } else {<Option<&'lt str>>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _delayitem0_7_83 = if let RetTypeEnum::Enumvariant_82(_rr_82)=parser.popstack().value { _rr_82 } else {<(Option<LBox<NEWSEQNT_8_0<'lt>>>,primary<'lt>,)>::default()};  RetTypeEnum::Enumvariant_0(_rrsemaction_65_(parser,_delayitem0_7_83,_item2_,_item3_)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWDELAYNT_NEWRENT_1_0_53");
 rule.Ruleaction = |parser|{ let mut yacc_declarations = if let RetTypeEnum::Enumvariant_77(_rr_77)=parser.popstack().value { _rr_77 } else {<Vec<LC<yacc_decl<'lt>>>>::default()};  RetTypeEnum::Enumvariant_87(_rrsemaction_66_(parser,yacc_declarations)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("NEWDELAYNT_NEWRENT_1_0_53");
 rule.Ruleaction = |parser|{ let mut yacc_declarations = if let RetTypeEnum::Enumvariant_77(_rr_77)=parser.popstack().value { _rr_77 } else {<Vec<LC<yacc_decl<'lt>>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_72(_rr_72)=parser.popstack().value { _rr_72 } else {<&'lt str>::default()};  RetTypeEnum::Enumvariant_87(_rrsemaction_67_(parser,_item0_,yacc_declarations)) };
 parser1.Rules.push(rule);
 rule = BaseProduction::<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>::new_skeleton("primary");
 rule.Ruleaction = |parser|{ let mut rules = if let RetTypeEnum::Enumvariant_54(_rr_54)=parser.popstack().value { _rr_54 } else {<Vec<LC<grammar_rules<'lt>>>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_76(_rr_76)=parser.popstack().value { _rr_76 } else {<()>::default()}; let mut _delayitem0_0_88 = if let RetTypeEnum::Enumvariant_87(_rr_87)=parser.popstack().value { _rr_87 } else {<(Option<&'lt str>,Vec<LC<yacc_decl<'lt>>>,)>::default()};  RetTypeEnum::Enumvariant_61(_rrsemaction_68_(parser,_delayitem0_0_88,_item1_,rules)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert("SEMICOLON");
 parser1.resynch.insert("BAR");

 for i in 0..449 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'lt>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,yacclexer<'lt>>) -> Result<Yacc<'lt>,Yacc<'lt>>
{
  parser.tokenizer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse() {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Yacc<'lt>>::default())}
}//parse_with public function

pub fn parse_train_with<'lt>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,yacclexer<'lt>>, parserpath:&str) -> Result<Yacc<'lt>,Yacc<'lt>>
{
  parser.tokenizer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse_train(parserpath) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Yacc<'lt>>::default())}
}//parse_train_with public function

//Enum for return values 
pub enum RetTypeEnum<'lt> {
  Enumvariant_53(Vec<LC<idnum<'lt>>>),
  Enumvariant_87((Option<&'lt str>,Vec<LC<yacc_decl<'lt>>>,)),
  Enumvariant_9(u32),
  Enumvariant_54(Vec<LC<grammar_rules<'lt>>>),
  Enumvariant_2((usize,usize)),
  Enumvariant_59(Option<LBox<&'lt str>>),
  Enumvariant_63(Option<u32>),
  Enumvariant_58(yacc_decl<'lt>),
  Enumvariant_76(()),
  Enumvariant_62(NEWSEQNT_8_0<'lt>),
  Enumvariant_78(semcontent<'lt>),
  Enumvariant_56(Vec<LC<rhs<'lt>>>),
  Enumvariant_60(unionset),
  Enumvariant_0(Yacc<'lt>),
  Enumvariant_69(rhsunit<'lt>),
  Enumvariant_72(&'lt str),
  Enumvariant_57(tag<'lt>),
  Enumvariant_49(idnum<'lt>),
  Enumvariant_64(grammar_rules<'lt>),
  Enumvariant_75(label<'lt>),
  Enumvariant_65(Vec<LC<&'lt str>>),
  Enumvariant_82((Option<LBox<NEWSEQNT_8_0<'lt>>>,primary<'lt>,)),
  Enumvariant_74(rhs<'lt>),
  Enumvariant_71(Option<&'lt str>),
  Enumvariant_70(Option<LBox<NEWSEQNT_8_0<'lt>>>),
  Enumvariant_68(Option<LBox<semaction<'lt>>>),
  Enumvariant_66(rhs_symbol<'lt>),
  Enumvariant_45(semstart),
  Enumvariant_48(semaction<'lt>),
  Enumvariant_52(Vec<LC<semcontent<'lt>>>),
  Enumvariant_73(Option<LBox<label<'lt>>>),
  Enumvariant_77(Vec<LC<yacc_decl<'lt>>>),
  Enumvariant_79(Vec<LC<rhsunit<'lt>>>),
  Enumvariant_61(primary<'lt>),
}
impl<'lt> Default for RetTypeEnum<'lt> { fn default()->Self {RetTypeEnum::Enumvariant_0(<Yacc<'lt>>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct yacclexer<'lt> {
   stk: StrTokenizer<'lt>,
   keywords: HashSet<&'static str>,
   lexnames: HashMap<&'static str,&'static str>,
   shared_state: Rc<RefCell<symbol_table<'lt>>>,
}
impl<'lt> yacclexer<'lt> 
{
  pub fn from_str(s:&'lt str) -> yacclexer<'lt>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'lt LexSource<'lt>) -> yacclexer<'lt>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'lt>) -> yacclexer<'lt> {
    let mut lexnames = HashMap::with_capacity(64);
    let mut keywords = HashSet::with_capacity(64);
    let shared_state = Rc::new(RefCell::new(<symbol_table<'lt>>::default()));
    for kw in ["_WILDCARD_TOKEN_","union",] {keywords.insert(kw);}
    for c in ['|',')','{','(',',','>','%','$','+','?',']',';','@','[','}','<',':','-','*',] {stk.add_single(c);}
    for d in ["%{","$$","%%","%}",] {stk.add_double(d);}
    for d in [] {stk.add_triple(d);}
    for (k,v) in [(r#"|"#,"BAR"),(r#"%{"#,"PERLBRACK"),(r#")"#,"RPAREN"),(r#"{"#,"LBRACE"),(r#"("#,"LPAREN"),(r#","#,"COMMA"),(r#">"#,"RANGLE"),(r#"%"#,"PERCENT"),(r#"$"#,"DOLLAR"),(r#"$$"#,"TWODOLLARS"),(r#"+"#,"PLUS"),(r#"?"#,"QUEST"),(r#"]"#,"RBRACK"),(r#";"#,"SEMICOLON"),(r#"@"#,"AT"),(r#"["#,"LBRACK"),(r#"%%"#,"PERPERCENT"),(r#"}"#,"RBRACE"),(r#"<"#,"LANGLE"),(r#":"#,"COLON"),(r#"%}"#,"PERRBRACK"),(r#"-"#,"DASH"),(r#"*"#,"STAR"),] {lexnames.insert(k,v);}
    stk.add_custom("literal",r"^'.'");
    stk.add_custom("%type",r"^%type");
    stk.add_custom("%token",r"^%token");
    stk.add_custom("%left",r"^%left");
    stk.add_custom("%right",r"^%right");
    stk.add_custom("%nonassoc",r"^%nonassoc");
    stk.add_custom("%start",r"^%start");
    stk.add_custom("decls",r"^(?m)^%\{(?s)[^%\}]*%\}");
    yacclexer {stk,keywords,lexnames,shared_state,}
  }
}
impl<'lt> Tokenizer<'lt,RetTypeEnum<'lt>> for yacclexer<'lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'lt,RetTypeEnum<'lt>>> {
    if self.shared_state.borrow().skip { self.stk.skip_to("$_RREOF_$"); }
    if self.shared_state.borrow().skip_match { self.stk.skip_match("{","}",1,"-->") }
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => {
        let truesym = self.lexnames.get(sym).unwrap_or(&sym);
        Some(TerminalToken::from_raw(token,truesym,<RetTypeEnum<'lt>>::default()))
      },
      RawToken:: Skipmatched(d)  => Some(TerminalToken::from_raw(token,"ACTION",RetTypeEnum::Enumvariant_72( d
))),
      RawToken:: Skipto(d)  => Some(TerminalToken::from_raw(token,"ADDITIONALS",RetTypeEnum::Enumvariant_72( d
))),
      RawToken:: Custom("decls",d)  => Some(TerminalToken::from_raw(token,"RAWDECL",RetTypeEnum::Enumvariant_72( &d.trim()[2..d.len()-2]
))),
      RawToken:: Alphanum(n)  => Some(TerminalToken::from_raw(token,"ID",RetTypeEnum::Enumvariant_72( n
))),
      RawToken:: Custom("literal",d) => Some(TerminalToken::from_raw(token,"LEXCHAR",RetTypeEnum::Enumvariant_72( d[1..d.len()-1].trim()
))),
      RawToken:: Strlit(d) => Some(TerminalToken::from_raw(token,"LEXSTR",RetTypeEnum::Enumvariant_72( d[1..d.len()-1].trim()
))),
      RawToken:: Num(n)  => Some(TerminalToken::from_raw(token,"NUMBER",RetTypeEnum::Enumvariant_9( n as u32
))),
      RawToken:: Custom("%type",_)  => Some(TerminalToken::from_raw(token,"PERTYPE",RetTypeEnum::Enumvariant_76( ()
))),
      RawToken:: Custom("%token",_)  => Some(TerminalToken::from_raw(token,"PERTOKEN",RetTypeEnum::Enumvariant_76( ()
))),
      RawToken:: Custom("%left",_)  => Some(TerminalToken::from_raw(token,"PERLEFT",RetTypeEnum::Enumvariant_76( ()
))),
      RawToken:: Custom("%right",_)  => Some(TerminalToken::from_raw(token,"PERRIGHT",RetTypeEnum::Enumvariant_76( ()
))),
      RawToken:: Custom("%nonassoc",_)  => Some(TerminalToken::from_raw(token,"PERNONASSOC",RetTypeEnum::Enumvariant_76( ()
))),
      RawToken:: Custom("%start",_)  => Some(TerminalToken::from_raw(token,"PERSTART",RetTypeEnum::Enumvariant_76( ()
))),
      RawToken::Symbol(s) if self.lexnames.contains_key(s) => {
        let tname = self.lexnames.get(s).unwrap();
        Some(TerminalToken::from_raw(token,tname,<RetTypeEnum<'lt>>::default()))
      },
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      _ => { let _rrodb=token.0.to_staticstr(); Some(TerminalToken::from_raw(token,_rrodb,<RetTypeEnum<'lt>>::default())) },
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
   fn add_priority_symbol(&mut self, s:&'static str) {self.stk.add_priority_symbol(s);}
   fn get_slice(&self,s:usize,l:usize) -> &str {self.stk.get_slice(s,l)}
   fn transform_wildcard(&self,t:TerminalToken<'lt,RetTypeEnum<'lt>>) -> TerminalToken<'lt,RetTypeEnum<'lt>> { TerminalToken::new(t.sym,RetTypeEnum::Enumvariant_72(self.stk.current_text()),t.line,t.column) }
}//impl Tokenizer

fn load_extras<'lt,TT:Tokenizer<'lt,RetTypeEnum<'lt>>>(parser:&mut BaseParser<'lt,RetTypeEnum<'lt>,symbol_table<'lt>,TT>)
{
}//end of load_extras: don't change this line as it affects augmentation
